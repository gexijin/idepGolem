name: Build macOS (Electron + R.framework)

on:
  workflow_dispatch:

  # push:
  #   branches:
  #     - electron-packaging
  #     - 'rel*'
  #   tags:
  #     - 'v*'
  #   paths:
  #     - "electron/**"
  #     - "R/**"
  #     - "app.R"
  #     - "DESCRIPTION"
  #     - "package.json"
  #     - ".github/workflows/build-electron-mac.yml"      

jobs:
  build:
    runs-on: macos-latest
    defaults:
      run:
        shell: bash

    # ðŸ” Signing / Notarization creds â€“ set these as GitHub secrets
    env:
      # SKIP_NOTARIZE: "true"
      # P12_BASE64: ${{ secrets.P12_BASE64 }}
      # CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
      # APPLE_ID: ${{ secrets.MAC_APPLE_ID }}
      # APPLE_ID_PASSWORD: ${{ secrets.MAC_APPLE_ID_PASSWORD }}
      # APPLE_TEAM_ID: ${{ secrets.MAC_APPLE_TEAM_ID }}
      # APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.MAC_APP_SPECIFIC_PASSWORD }}
      CI: "true" 

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect package directory
        id: detect-pkgdir
        run: |
          set -euo pipefail

          if [ -f "electron/package.json" ]; then
            PACKAGE_DIR="electron"
          elif [ -f "package.json" ]; then
            PACKAGE_DIR="."
          else
            echo "package.json not found at repo root or electron/" >&2
            exit 1
          fi

          echo "PACKAGE_DIR=$PACKAGE_DIR" >> "$GITHUB_ENV"
          echo "PACKAGE_DIR = $PACKAGE_DIR"

      - name: Detect R package source (idepGolem)
        run: |
          set -euo pipefail
          desc_path=$(grep -rl "^Package:[[:space:]]*idepGolem\b" . || true)
          if [ -z "$desc_path" ]; then
            echo "idepGolem package source not found" >&2
            exit 1
          fi
          PKG_SRC=$(dirname "$desc_path" | head -n 1)
          echo "PKG_SRC=$PKG_SRC" >> "$GITHUB_ENV"
          echo "PKG_SRC = $PKG_SRC"

      - name: Fix invalid filename in R/ (leading underscore)
        run: |
          set -euo pipefail
          bad="$PKG_SRC/R/_disable_autoload.R"
          if [ -f "$bad" ]; then
            mv "$bad" "$PKG_SRC/R/z_disable_autoload.R"
          fi

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: ${{ env.PACKAGE_DIR }}/package-lock.json

      - name: Install npm deps
        working-directory: ${{ env.PACKAGE_DIR }}
        run: |
          set -euxo pipefail
          if [ -f package-lock.json ]; then
            npm ci || (rm -rf node_modules && npm install --no-fund --no-audit)
          else
            npm install --no-fund --no-audit
          fi

      - name: Ensure electron-builder present
        working-directory: ${{ env.PACKAGE_DIR }}
        run: |
          set -euxo pipefail
          if ! npx --yes --package=electron-builder@26.0.12 --call "echo ok" >/dev/null 2>&1; then
            npm install -D electron-builder@26.0.12
          fi

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.4.1'

      # Mirror R.home() into runtime/R.framework/Resources
      - name: Stage R.framework (mirror R.home() into runtime/R.framework/Resources)
        run: |
          set -euo pipefail
          RHOME=$(Rscript -e "cat(R.home())")
          if [ -z "$RHOME" ]; then
            echo "Could not get R.home()" >&2
            exit 1
          fi

          dst_root="${PACKAGE_DIR}/runtime/R.framework"
          dst="${dst_root}/Resources"

          mkdir -p "$dst"
          rsync -a "${RHOME}/" "${dst}/"

          echo "RHOME         = $RHOME"
          echo "Bundled ROOT  = $dst_root"
          echo "Bundled RHOME = $dst"

          if [ -f "${dst}/bin/Rscript" ]; then
            chmod +x "${dst}/bin/Rscript"
          fi

      - name: Resolve bundled paths (debug)
        run: |
          set -euo pipefail
          app="$PACKAGE_DIR"
          rscript="$app/runtime/R.framework/Resources/bin/Rscript"
          lib="$app/runtime/R.framework/Resources/library"
          echo "APP:      $app"
          echo "Rscript:  $rscript"
          echo "LIB PATH: $lib"
          if [ ! -x "$rscript" ]; then
            echo "Bundled Rscript not found or not executable: $rscript" >&2
            ls -R "$app/runtime" || true
            exit 1
          fi
          mkdir -p "$lib"

      - name: Detect package name from DESCRIPTION
        run: |
          set -euo pipefail
          desc="$PKG_SRC/DESCRIPTION"
          if [ ! -f "$desc" ]; then
            echo "DESCRIPTION not found at: $desc" >&2
            exit 1
          fi
          PKG_NAME=$(grep "^Package:" "$desc" | head -n1 | awk '{print $2}')
          if [ -z "$PKG_NAME" ]; then
            echo "Could not parse Package field in: $desc" >&2
            exit 1
          fi
          echo "PKG_NAME=$PKG_NAME" >> "$GITHUB_ENV"
          echo "PKG_NAME = $PKG_NAME"        
          
      # Patch DESCRIPTION in CI only: drop ggalt from Imports so it's not a hard dep
      - name: Patch DESCRIPTION for app build (drop ggalt from Imports)
        run: |
          set -euo pipefail
          desc="$PKG_SRC/DESCRIPTION"
          echo "[patch-desc] Patching DESCRIPTION at: $desc"

          Rscript -e "
            desc_path <- '$desc'
            d <- read.dcf(desc_path)

            if (!'Imports' %in% colnames(d)) {
              stop('No Imports field in DESCRIPTION')
            }

            im <- strsplit(d[1, 'Imports'], ',')[[1]]
            im <- trimws(im)
            im <- im[im != 'ggalt']

            if (length(im)) {
              d[1, 'Imports'] <- paste(im, collapse = ',\n    ')
            } else {
              d[1, 'Imports'] <- ''
            }

            write.dcf(d, desc_path)
            cat('[patch-desc] New Imports:\\n', d[1, 'Imports'], '\\n')
          "          

      - name: Install ottoPlots into bundled R.framework library
        env:
          GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          app="$PACKAGE_DIR"
          R_BIN="$app/runtime/R.framework/Resources/bin/Rscript"
          LIB="$app/runtime/R.framework/Resources/library"

          "$R_BIN" -e "
            lib <- '$LIB'
            dir.create(lib, showWarnings = FALSE, recursive = TRUE)
            .libPaths(lib)
            repos <- c(CRAN = 'https://cran.r-project.org')
            if (!requireNamespace('remotes', quietly = TRUE)) {
              install.packages('remotes', lib = lib, repos = repos)
            }
            options(Ncpus = max(1L, parallel::detectCores() - 1L))
            remotes::install_github('espors/ottoPlots',
                                    lib          = lib,
                                    dependencies = TRUE,
                                    upgrade      = 'never',
                                    quiet        = TRUE)
            cat('Installed ottoPlots into:', lib, '\n')
          "

      - name: Install DESCRIPTION deps into bundled library
        run: |
          set -euo pipefail
          app="$PACKAGE_DIR"
          lib="$app/runtime/R.framework/Resources/library"
          rscript="$app/runtime/R.framework/Resources/bin/Rscript"
          desc="$PKG_SRC/DESCRIPTION"

          libR="${lib//\\//}"
          descR="${desc//\\//}"

          cat > install_desc.R << 'EOF'
          args <- commandArgs(trailingOnly=TRUE)
          desc <- args[1]
          lib  <- args[2]

          if (!dir.exists(lib)) dir.create(lib, recursive = TRUE, showWarnings = FALSE)
          .libPaths(c(lib, .libPaths()))
          message("[install_desc] .libPaths() = ", paste(.libPaths(), collapse=" | "))
          message("[install_desc] Using lib: ", lib)
          message("[install_desc] DESCRIPTION: ", desc)

          opt_repos <- c(CRAN="https://cran.r-project.org")
          options(
            repos = opt_repos,
            Ncpus = max(1L, parallel::detectCores()-1L),
            warn  = 1
          )

          if (!requireNamespace("BiocManager", quietly=TRUE))
            install.packages("BiocManager", repos=opt_repos["CRAN"], lib=lib)

          if (!requireNamespace("remotes", quietly=TRUE))
            install.packages("remotes", repos=opt_repos["CRAN"], lib=lib)

          d <- read.dcf(desc)

          parse_field <- function(field) {
            if (!field %in% colnames(d)) return(character())
            x <- gsub("\\n", " ", d[1, field])
            x <- unlist(strsplit(x, ","))
            x <- gsub("\\s*\\(.*?\\)\\s*", "", x)
            trimws(x)
          }

          pkgs <- unique(c(parse_field("Depends"), parse_field("Imports")))
          pkgs <- setdiff(pkgs, c("R","base"))

          message("[install_desc] DESCRIPTION deps: ", paste(pkgs, collapse=", "))

          bioc_pkgs <- intersect(
            pkgs,
            c(
              "DESeq2","edgeR","ComplexHeatmap","GSVA","gage",
              "hgu133plus2.db","InteractiveComplexHeatmap","PCAtools",
              "pathview","QUBIC","fgsea","WGCNA",
              "GO.db","SummarizedExperiment","Biobase",
              "limma","KEGGREST","preprocessCore"
            )
          )
          cran_pkgs <- setdiff(pkgs, bioc_pkgs)

          message("[install_desc] CRAN subset: ", paste(cran_pkgs, collapse=", "))
          message("[install_desc] Bioc subset: ", paste(bioc_pkgs, collapse=", "))

          if (length(cran_pkgs)) {
            install.packages(cran_pkgs, lib=lib, dependencies=TRUE)
          }

          if (length(bioc_pkgs)) {
            BiocManager::install(bioc_pkgs, lib=lib, ask=FALSE, update=FALSE)
          }

          # ggalt is archived; special-case it and FORCE it (best-effort)
          if (!"ggalt" %in% rownames(installed.packages(lib.loc=lib))) {
            message("[install_desc] Trying to install ggalt 0.4.0 from CRAN archive")
            try(
            remotes::install_version(
              "ggalt",
              version      = "0.4.0",
              lib          = lib,
              upgrade      = "never",
              dependencies = TRUE
              ),
              silent = TRUE
            )
          }

          ip <- installed.packages(lib.loc = lib)
          message("[install_desc] Installed packages in bundled lib: ", nrow(ip))

          # Hard requirements for mac (ggalt excluded now)
          target <- c(
            "ComplexHeatmap","DESeq2","gage","ggraph","hgu133plus2.db",
            "InteractiveComplexHeatmap","pathview","plotly","png",
            "GSVA","WGCNA"
          )

          check_one <- function(pkg) {
            present <- pkg %in% rownames(ip)
            message(sprintf("[install_desc]   %-25s : %s",
                            pkg, if (present) "OK" else "MISSING"))
            present
          }

          missing_logical <- !vapply(target, check_one, logical(1))
          missing <- target[missing_logical]

          # ggalt reported but not enforced
          if (!"ggalt" %in% rownames(ip)) {
            message("[install_desc] WARNING: ggalt is missing (optional for app build).")
          } else {
            message("[install_desc] ggalt present.")
          }

          if (length(missing)) {
            stop("Missing required packages for idepGolem on macOS: ",
                 paste(missing, collapse=", "))
          } else {
            message("[install_desc] All key idepGolem deps present.")
          }
          EOF

          "$rscript" install_desc.R "$descR" "$libR"

      - name: Build and install idepGolem into R.framework/Resources/library
        env:
          _R_CHECK_FORCE_SUGGESTS_: "false"
          R_BUILD_DONTFAIL_ON_WARNING_: "true"
          R_BUILD_TAR: tar
          TAR: tar
        run: |
          set -euo pipefail
          app="$PACKAGE_DIR"
          lib="$app/runtime/R.framework/Resources/library"
          Rexe="$app/runtime/R.framework/Resources/bin/R"
          libR="$lib"

          pushd "$PKG_SRC"
          "$Rexe" CMD build . --no-build-vignettes --no-manual
          tarball=$(ls -1t *.tar.gz | head -n1 || true)
          popd
          if [ -z "$tarball" ]; then
            echo "Package tarball not found after build" >&2
            exit 1
          fi
          export R_LIBS="$libR"
          export R_LIBS_USER="$libR"
          "$Rexe" CMD INSTALL --library="$lib" "$PKG_SRC/$tarball"

      - name: Stage app sources into electron/app
        run: |
          set -euo pipefail
          app="$PACKAGE_DIR"
          rm -rf "$app/app"
          mkdir -p "$app/app"
          cp -r "$PKG_SRC/R"        "$app/app/R"
          cp    "$PKG_SRC/app.R"    "$app/app/app.R"
          cp    "$PKG_SRC/DESCRIPTION" "$app/app/DESCRIPTION"

      - name: Verify required pkgs in bundled lib
        run: |
          set -euo pipefail
          r="$PACKAGE_DIR/runtime/R.framework/Resources/bin/Rscript"
          libR="$PACKAGE_DIR/runtime/R.framework/Resources/library"
          "$r" -e "lp <- '$libR'; cat('hgu133plus2.db:', 'hgu133plus2.db' %in% rownames(installed.packages(lib.loc=lp)), '\n')"

      - name: Show current file descriptor limits
        run: |
          set -euxo pipefail
          ulimit -n
          sysctl kern.maxfiles
          sysctl kern.maxfilesperproc

      - name: Raise macOS file descriptor limits
        run: |
          set -euxo pipefail
          # Raise system-wide and per-process file descriptor limits
          sudo sysctl -w kern.maxfiles=65536
          sudo sysctl -w kern.maxfilesperproc=65536

          # Now raise the per-shell limit for this build step
          ulimit -n 65536 || ulimit -n 16384 || ulimit -n 8192

      - name: Prune R library (docs, examples, tests)
        run: |
          set -euxo pipefail
          R_LIB="$PACKAGE_DIR/runtime/R.framework/Resources/library"

          # Remove help/docs/examples/tests/vignettes etc.
          find "$R_LIB" -type d \( \
            -name help -o -name doc -o -name docs -o \
            -name html -o -name examples -o -name demo -o \
            -name tests -o -name testthat -o -name unitTests -o \
            -name vignettes \
          \) -prune -exec rm -rf {} +

          # Optionally strip native libs to shrink them
          find "$R_LIB" \( -name "*.so" -o -name "*.dylib" \) -exec strip -x {} \; || true


      - name: Build (npm run dist)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        working-directory: ${{ env.PACKAGE_DIR }}
        run: |
          set -euxo pipefail
          # still keep this, but it should now succeed at 65536
          ulimit -n 65536 || ulimit -n 16384 || ulimit -n 8192
          npm run dist

      # - name: Notarize DMG (only on tags v*)
      #   working-directory: ${{ env.PACKAGE_DIR }}
      #   run: |
      #     set -euxo pipefail

      #     DMG_PATH=$(ls dist/*.dmg | head -n1)

      #     echo "Submitting $DMG_PATH for notarization..."
      #     xcrun notarytool submit "$DMG_PATH" \
      #       --apple-id "$APPLE_ID" \
      #       --team-id "$APPLE_TEAM_ID" \
      #       --password "$APPLE_APP_SPECIFIC_PASSWORD" \
      #       --wait

      #     echo "Stapling ticket..."
      #     xcrun stapler staple "$DMG_PATH"
      #     xcrun stapler validate "$DMG_PATH"

      - name: Upload dist artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mac-dist
          path: ${{ env.PACKAGE_DIR }}/dist/**
          if-no-files-found: error
          retention-days: 14
