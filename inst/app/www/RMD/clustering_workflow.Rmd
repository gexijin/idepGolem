---
title: "iDEP: clustering analysis"
output: 
  html_document:
    code_folding: hide
params:
  pre_processed_data:
  all_gene_names:
  descr:
  mapping_statistics:
  sample_info:
  n_genes:
  k_clusters:
  cluster_meth:
  select_gene_id:
  list_factors_heatmap:
  heatmap_color_select:
  dist_function:
  hclust_function:
  heatmap_cutoff:
  gene_centering:
  gene_normalize:
  sample_clustering:
  show_row_dend:
  selected_genes:
  submap_data:
  select_factors_heatmap:
  sample_color:
  cluster_enrichment_enabled:
  selection_enrichment_table:
  printcode:
    label: "Display Code"
    value: TRUE
    input: checkbox
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = params$printcode,
  warning = FALSE,
  message = FALSE
)
```

```{r format_enrichment_helper, include=FALSE}
format_enrichment_for_report <- function(enrichment_list) {
  if (is.null(enrichment_list) || length(enrichment_list) == 0) {
    return(NULL)
  }

  if (is.data.frame(enrichment_list)) {
    enrichment_list <- list(Selection = enrichment_list)
  }

  collapse_list_columns <- function(df) {
    df_copy <- as.data.frame(df, stringsAsFactors = FALSE)
    for (col in seq_along(df_copy)) {
      if (is.list(df_copy[[col]])) {
        df_copy[[col]] <- vapply(
          df_copy[[col]],
          function(x) paste0(unlist(x), collapse = ", "),
          character(1),
          USE.NAMES = FALSE
        )
      }
    }
    rownames(df_copy) <- NULL
    df_copy
  }

  indices <- seq_along(enrichment_list)
  rows <- lapply(indices, function(i) {
    tbl <- enrichment_list[[i]]
    if (is.null(tbl) || !is.data.frame(tbl)) {
      return(NULL)
    }
    if (ncol(tbl) == 1) {
      return(NULL)
    }
    group_name <- names(enrichment_list)[i]
    if (is.null(group_name) || is.na(group_name) || group_name == "") {
      group_name <- paste0("Group ", i)
    }
    df1 <- collapse_list_columns(tbl)
    df1$group <- group_name
    df1
  })

  rows <- Filter(Negate(is.null), rows)
  if (length(rows) == 0) {
    return(NULL)
  }

  res <- do.call(rbind, rows)
  if (is.null(res) || ncol(res) == 0) {
    return(NULL)
  }

  res <- as.data.frame(res, stringsAsFactors = FALSE)
  colnames(res) <- gsub("\\.", " ", colnames(res), perl = TRUE)

  if ("group" %in% colnames(res)) {
    if (length(unique(res$group)) == 1) {
      res$group <- NULL
    } else {
      res$group[duplicated(res$group)] <- ""
      colnames(res)[colnames(res) == "group"] <- "Grp."
    }
  }

  if ("FDR" %in% colnames(res)) {
    res$FDR <- gsub("e-0", "e-", res$FDR)
    res$FDR <- gsub("e", "E", res$FDR)
  }

  if ("nGenes" %in% colnames(res)) {
    res$nGenes <- as.character(res$nGenes)
  }

  if ("Fold enriched" %in% colnames(res)) {
    fold_vals <- suppressWarnings(as.numeric(res$`Fold enriched`))
    res$`Fold enriched` <- as.character(round(fold_vals, 1))
  }

  if ("Pathway size" %in% colnames(res)) {
    res$`Pathway size` <- as.character(res$`Pathway size`)
  }

  if (all(c("Pathway", "URL") %in% colnames(res))) {
    res$Pathway <- hyperText(res$Pathway, res$URL)
  }

  drop_cols <- colnames(res) %in% c("Genes", "URL")
  if (any(drop_cols)) {
    res <- res[, !drop_cols, drop = FALSE]
  }

  colnames(res) <- gsub("Pathway size", "PathwaySize", colnames(res))
  colnames(res) <- gsub("Fold enriched", "Fold", colnames(res))
  colnames(res) <- gsub("FDR", "Adj.Pval", colnames(res))

  if ("PathwaySize" %in% colnames(res)) {
    res$PathwaySize <- NULL
  }

  if ("Pathway" %in% colnames(res)) {
    colnames(res)[colnames(res) == "Pathway"] <- "Pathway (Click for more info)"
  }

  if ("nGenes" %in% colnames(res)) {
    res$nGenes <- NULL
  }

  return(res)
}
```

<!-- This document cannot be knit directly from R studio -->

<div>

::: {style="color: Blue"}
## If this site has contributed to your work, please cite our article:

Ge, S.X., Son, E.W. & Yao, R. iDEP: an integrated web application for differential expression and pathway analysis of RNA-Seq data. BMC Bioinformatics 19, 534 (2018). <https://doi.org/10.1186/s12859-018-2486-6>
:::

##

</div>

------------------------------------------------------------------------


<!-- `r params$descr` -->

<!--ALL SELECTED PARAMETERS-->

```{r, include=FALSE}
for (i in 1:length(params)) {
  # exclude loaded data & sample info
  if (names(params)[i] != "sample_info" &&
      names(params)[i] != "pre_processed_data" &&
      names(params)[i] != "all_gene_names" &&
      names(params)[i] != "mapping_statistics" &&
      names(params)[i] != "submap_data") {
    cat(paste0(names(params)[i], ": ", params[[i]], "\n"))
  }
}
```

```{r, include=FALSE}
# Map distance function number to name
dist_funs <- dist_functions()
dist_name <- names(dist_funs)[as.numeric(params$dist_function)]
```

## Summary

`r params$descr`

`r if (!is.null(params$mapping_statistics)) params$mapping_statistics else ""`

Clustering analysis included the top `r params$n_genes` genes based on `r params$select_gene_id`. `r if(params$cluster_meth == "1") paste0("Hierarchical clustering was applied using ", params$hclust_function, " linkage") else paste0("K-means clustering was performed with ", params$k_clusters, " clusters")` with `r dist_name` distance metric. `r if(params$gene_centering) "Genes were centered" else "Genes were not centered"``r if(params$gene_normalize) " and normalized" else ""`. The heatmap color scheme used was `r paste(params$heatmap_color_select, collapse = ", ")` with a Z-score cutoff of `r params$heatmap_cutoff`. `r if(!params$sample_clustering) "Sample clustering was disabled" else "Samples were clustered"`.

```{r process_heatmap_data, include=FALSE}
heatmap_data <- process_heatmap_data(
  data = params$pre_processed_data,
  n_genes_max = params$n_genes,
  # n_genes_min = 50,
  gene_centering = params$gene_centering,
  gene_normalize = params$gene_normalize,
  sample_centering = TRUE,
  sample_normalize = TRUE,
  all_gene_names = params$all_gene_names,
  select_gene_id = params$select_gene_id
)
```


## Heatmap

```{r fig.height=6, fig.width=max(4, min(12, ncol(heatmap_data) * 0.2))}
# Subset sample_info to match heatmap_data columns
sample_info_subset <- NULL
if (!is.null(params$sample_info)) {
  # Match sample_info rows to heatmap_data columns
  sample_info_subset <- params$sample_info[match(colnames(heatmap_data), rownames(params$sample_info)), , drop = FALSE]
}

# Prepare group palette for annotation if needed
group_pal_main <- NULL
if (!is.null(params$select_factors_heatmap) &&
    params$select_factors_heatmap == "All factors" &&
    !is.null(sample_info_subset)) {
  groups <- as.vector(as.matrix(sample_info_subset))
  pal <- setNames(
    colorspace::qualitative_hcl(
      length(unique(groups)),
      palette = params$sample_color,
      c = 70
    ),
    unique(groups)
  )
  sample_list <- as.list(as.data.frame(sample_info_subset))
  group_pal_main <- lapply(sample_list, function(x) {
    setNames(
      pal[unique(x)],
      unique(x)
    )
  })
}

ht <- heatmap_main(
  data = heatmap_data,
  cluster_meth = params$cluster_meth,
  heatmap_cutoff = params$heatmap_cutoff,
  sample_info = sample_info_subset,
  select_factors_heatmap = params$select_factors_heatmap,
  dist_funs = dist_functions(),
  dist_function = params$dist_function,
  hclust_function = params$hclust_function,
  sample_clustering = params$sample_clustering,
  heatmap_color_select = params$heatmap_color_select,
  row_dend = params$show_row_dend,
  k_clusters = params$k_clusters,
  re_run = FALSE,
  selected_genes = params$selected_genes,
  group_pal = group_pal_main,
  sample_color = params$sample_color,
  show_column_names = TRUE
)
```

<br>

## Sub Heatmap

`r ifelse(!is.null(params$submap_data), "The following heatmap shows the zoomed-in selection from the main heatmap:", "")`

```{r sub_heatmap, fig.height=if(!is.null(params$submap_data)) max(6, min(300, nrow(params$submap_data) * 0.15)) else 6, fig.width=if(!is.null(params$submap_data)) max(4, min(12, ncol(params$submap_data) * 0.2)) else 8}
if (!is.null(params$submap_data)) {
  # Subset sample_info to match submap_data columns
  sample_info_sub <- NULL
  if (!is.null(params$sample_info)) {
    # Match sample_info rows to submap_data columns
    sample_info_sub <- params$sample_info[match(colnames(params$submap_data), rownames(params$sample_info)), , drop = FALSE]
  }

  # Prepare group palette for annotation if needed
  group_pal_val <- NULL
  if (!is.null(params$select_factors_heatmap) &&
      params$select_factors_heatmap == "All factors" &&
      !is.null(sample_info_sub)) {
    groups <- as.vector(as.matrix(sample_info_sub))
    pal <- setNames(
      colorspace::qualitative_hcl(
        length(unique(groups)),
        palette = params$sample_color,
        c = 70
      ),
      unique(groups)
    )
    sample_list <- as.list(as.data.frame(sample_info_sub))
    group_pal_val <- lapply(sample_list, function(x) {
      setNames(
        pal[unique(x)],
        unique(x)
      )
    })
  }

  # Create annotation for sub heatmap
  sub_heat <- sub_heat_ann(
    data = params$submap_data,
    sample_info = sample_info_sub,
    select_factors_heatmap = params$select_factors_heatmap,
    group_pal = group_pal_val,
    sample_color = params$sample_color
  )

  # Color function matching the main heatmap
  # Apply cutoff filter like in the main heatmap
  cutoff <- median(unlist(params$submap_data)) +
    params$heatmap_cutoff * sd(unlist(params$submap_data))
  sub_data <- params$submap_data
  sub_data[sub_data > cutoff] <- cutoff
  cutoff <- median(unlist(params$submap_data)) -
    params$heatmap_cutoff * sd(unlist(params$submap_data))
  sub_data[sub_data < cutoff] <- cutoff

  # Create color scale matching main heatmap logic
  if (min(sub_data) < 0) {
    col_fun <- circlize::colorRamp2(
      c(min(sub_data), 0, max(sub_data)),
      params$heatmap_color_select
    )
  } else {
    col_fun <- circlize::colorRamp2(
      c(min(sub_data), median(sub_data), max(sub_data)),
      params$heatmap_color_select
    )
  }

  # Determine if row names should be shown
  show_rows <- nrow(sub_data) <= 2000

  # Create sub heatmap
  ht_sub <- ComplexHeatmap::Heatmap(
    sub_data,
    col = col_fun,
    show_heatmap_legend = FALSE,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = show_rows,
    top_annotation = sub_heat$heat_sub_ann,
    name = "sub_heat",
    heatmap_legend_param = list(
      direction = "horizontal",
      legend_width = grid::unit(6, "cm"),
      title = "Color Key",
      title_position = "topcenter"
    )
  )

  # Draw the heatmap
  ComplexHeatmap::draw(
    ht_sub,
    annotation_legend_list = sub_heat$lgd,
    annotation_legend_side = "top",
    heatmap_legend_side = "bottom"
  )
}
```

```{r hierarchical_enrichment_table, echo=FALSE, results='asis'}
if (params$cluster_meth == 1 &&
    isTRUE(params$cluster_enrichment_enabled) &&
    !is.null(params$submap_data)) {

  enrichment_table <- params$selection_enrichment_table

  if (!is.null(enrichment_table)) {
    formatted_table <- format_enrichment_for_report(enrichment_table)

    cat("## Pathway Enrichment for Selected Region\n\n")

    if (!is.null(formatted_table)) {
      print(knitr::kable(
        formatted_table,
        format = "html",
        escape = FALSE
      ))
    } else {
      cat("No significant enrichment found.\n")
    }
  }
}
```

<br>

## SD Density

```{r sd_density}
sd_density(
  data = params$pre_processed_data,
  n_genes_max = params$n_genes
)
```

<br>

`r ifelse(as.character(params$dist_function) == "1","## Hierarchical clustering tree","")`
```{r}
if (params$dist_function == 1) {
  draw_sample_tree(
    tree_data = params$pre_processed_data,
    gene_centering = params$gene_centering,
    gene_normalize = params$gene_normalize,
    sample_centering = FALSE,
    sample_normalize = FALSE,
    hclust_funs = hcluster_functions(),
    hclust_function = params$hclust_function,
    dist_funs = dist_functions(),
    dist_function = params$dist_function
  )
}
```

<br>

## Elbow Plot

```{r}
k_means_elbow(heatmap_data = heatmap_data)
```

<!-- # Correlation Matrix (Not included in app) -->
<!-- ```{r} -->
<!-- cor_plot( -->
<!--   data = params$pre_processed_data, -->
<!--   label_pcc = TRUE, -->
<!--   heat_cols = c("red", "black", "green"), -->
<!--   text_col = "white" -->
<!-- ) -->
<!-- ``` -->

<br>
Generated using iDEP v`r packageVersion("idepGolem")` (https://bioinformatics.sdstate.edu/idep). `r format(Sys.time(), "%Y-%m-%d %H:%M:%S %Z")`. Accuracy not guaranteed.
